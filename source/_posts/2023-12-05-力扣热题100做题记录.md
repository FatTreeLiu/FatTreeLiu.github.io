---
title: 力扣热题100做题记录
categories:
  - 数据结构与算法
tags:
  - 面试
date: 2023-12-05 22:16:55
---

# 前言

只有写出来，才是自己的，算法题也得好好做笔记。

# 记录

## 力扣-1. 两数之和

### 题目

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

### 题解

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++){
            if (map.containsKey(target - nums[i])){
                int[] res = new int[2];
                res[0] = map.get(target - nums[i]);
                res[1] = i;
                return res;
            }
            map.put(nums[i], i);
        }
        return new int[2];
    }
}
```

### 分析

如果这个题目限制为不重复的整数数据，那么也可以先排序，利用双指针前后夹逼。笔者开始就是这样做的，后来发现题目没有审好，所以一定要注意审题。笔者也想过先构建<值，索引>的map，然后排序，然后双指针夹逼，后来发现因为值会重复覆盖，导致索引重复。

这个题目做过几次，感觉官方的题解比较优雅，就是上方的题解。遍历数据，在把当前数值和索引放进map前先找是否有符合的数值，这样就可以巧妙的避免索引重复。

时间复杂度O(n)
空间复杂度O(n)

参考：
[两数之和](https://leetcode.cn/problems/two-sum/description/)

## 力扣-49. 字母异位词分组

### 题目

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

### 题解
```
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs){
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            if (map.containsKey(key)){
                map.get(key).add(str);
            } else {
                List<String> list = new ArrayList<>();
                list.add(str);
                map.put(key,list);
            }
        }
        List<List<String>> res = new ArrayList<>();
        for (Map.Entry<String,List<String>>  entry : map.entrySet()){
            res.add(entry.getValue());
        }
        return res;  
    }
}
```

### 分析

此题一次性做出来了，方法感觉很暴力，但是确实也是比较优的方案了，api有些生疏了，但是竟然磕磕绊绊写出来了。。。后续要复习，熟悉下相关的api。
一点心得，有时解题不要过于追求完美，先写出来，再写的快，再写的优美。

时间复杂度：O(nklog(k))，n为单数数量，k为单词长度，排序的复杂度是klog(k)
空间复杂度：O(nk)

参考：
[字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

## 力扣-128. 最长连续序列

### 题目

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

### 题解

```
// 首次不超时，速度倒数9%
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length <= 1){
            return nums.length;
        }
        Set<Integer> set = new HashSet<>();
        for (int num : nums){
            set.add(num);
        }
        int res = 1;
        for (int num : nums){
            int tLen = 1;
            int p = num;
            if (set.contains(p - 1)){
                continue;
            }
            while (set.contains(p + 1)){
                tLen += 1;
                p = p + 1;
            }
            res = Math.max(res, tLen);
        }
        return res;
    }
}
```

### 分析

第一次写超时了，因为没有把set.contains(p - 1)的分支剪掉，导致重复计算了，第二次剪掉了这个分支，速度仍然只击败了9%，看来下原来的逻辑基本和这个一样，这个题目的题解姑且这样吧。

时间复杂度：O(n)-O(n^2)
空间复杂度：O(n)

参考：
[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

## 力扣-283. 移动零

### 题目

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。

### 题解

```
// 我写了20分钟的答案
class Solution {
    public void moveZeroes(int[] nums) {
        int i = -1;
        for (int s = 0; s < nums.length; s++){
            if (nums[s] == 0){
                i = s;
                break;
            }
        }
        if (i == -1){
            return;
        }
        for (int j = i + 1; j < nums.length; j++){
            if (nums[j] != 0){
                sw(nums, i, j);
                i++;
            }
        }
    }
    public void sw(int[] nums, int i, int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

```
// 原来提交过的答案，优雅，实在是优雅
class Solution {
    public void moveZeroes(int[] nums) {
       int i = 0;
       for (int j = 0; j < nums.length; j++){
           if (nums[j] != 0){
               int t = nums[i];
               nums[i] = nums[j];
               nums[j] = t;
               i++;
           }
       }   
    }
}
```

### 分析

正确的答案总是那么优雅，好好背背吧，至少能少些几行垃圾代码

时间复杂度：O(n)
空间复杂度：O(1)

参考：
[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)


## 15. 三数之和

### 题目

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

### 题解
```
//又不是不能过解法
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        Set<String> set = new HashSet<>();
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < nums.length - 2; i++){
            int j = i + 1;
            int k = nums.length - 1;
            while(j < k){
                int sum = nums[j] + nums[k];
                if (sum > -nums[i]){
                    k--;
                    continue;
                }
                if (sum < -nums[i]){
                    j++;
                    continue;
                }
                String key = nums[i] + "-" + nums[j] + "-" + nums[k];
                if (!set.contains(key)){
                    set.add(key);
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[k]);
                    res.add(list);
                }
                j++;
            }
        }
        return res;
    }
}
```

```
//优雅一点的解法
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < nums.length - 2; i++){
            if (nums[i] > 0){
                return res;
            }
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            int j = i + 1;
            int k = nums.length - 1;
            while(j < k){
                if (j > i + 1 && nums[j] == nums[j - 1]){
                    j++;
                    continue;
                }
                if (k < nums.length - 1 && nums[k] == nums[k + 1]){
                    k--;
                    continue;
                }
                int sum = nums[j] + nums[k];
                if (sum > -nums[i]){
                    k--;
                    continue;
                }
                if (sum < -nums[i]){
                    j++;
                    continue;
                }
                Integer[] arr = new Integer[]{nums[i],nums[j],nums[k]};
                res.add(Arrays.asList(arr));
                j++;
                k--;
            }
        }
        return res;
    }
}
```

### 分析

基本的思路是排序，然后双指针夹逼，需要注意的点是结果不能重复，所以我直接采用了暴力的HashSet进行去重。但是整体流程不是那么的优雅，更加优雅的方案是前面几个值固定时，当前值去重，一但当前值有重复的，很可能导致出现重复结果，所以需要跳过。

时间复杂度：O(n^2)
空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(log⁡N)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums的副本并进行排序，空间复杂度为 O(N)。

参考：
[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)
[力扣题解](https://leetcode.cn/problems/3sum/)


## 560. 和为 K 的子数组

### 题目

给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。

子数组是数组中元素的连续非空序列。

### 题解
```
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        Map<Integer, Integer> map = new HashMap<>();
        int pre = 0;
        map.put(0, 1);
        for (int i = 0 ;i < nums.length; i++){
            pre = pre + nums[i];
            count += map.getOrDefault(pre - k, 0);
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```

### 分析

这个题目开始以为用双指针，想复杂了，看来题解，感觉前缀和还是是优雅。真是有点东西。

时间复杂度：O(n)。
空间复杂度：O(n)。

参考：
[和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)


## 76. 最小覆盖子串

### 题目

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。

### 题解
```
class Solution {
    public String minWindow(String s, String t) {
        String str = "";
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < t.length(); i++){
            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
        }
        int start = 0;
        int end = 0;
        map.put(s.charAt(end), map.getOrDefault(s.charAt(end), 0) - 1);
        while(end < s.length() && start <= end){
            if (hasSub(map)){
                if ("".equals(str)){
                    str = s.substring(start, end + 1);
                } else {
                    if ((end - start + 1) < str.length()){
                        str = s.substring(start, end + 1);
                    }
                }
                start++;
                map.put(s.charAt(start - 1),map.get(s.charAt(start - 1)) + 1);
                continue;
            } else {
                end++;
                if (end >= s.length()){
                    break;
                }
                map.put(s.charAt(end), map.getOrDefault(s.charAt(end), 0) - 1);
            }
        }
        return str;
    }
    public boolean hasSub(Map<Character, Integer> map){
        for (Map.Entry<Character, Integer> entry : map.entrySet()){
            if (entry.getValue() > 0){
                return false;
            }
        }
        return true;
    }
}
```

### 分析

旧笔记本坏了卖废品了，总算把新笔记本落实了，把博客环境搭建好，今天完成了笔记本坏前的一道hard题，虽然是hard，实际解题思路还是比较简单的，总体来说就是滑动窗口。
运行了几次都没有通过，仔细检查了下其实是String的substring(int start, int end)方法没有用对，这个方法包含start但是不包含end，所以end需要注意是否需要加1.


时间复杂度：O(n)，无论是start还是end，最多滑动一遍。
空间复杂度：O(n)。用到了Hashmap。

参考：
[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)


## 56. 合并区间

### 题目

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

### 题解
```
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> list = new ArrayList<>();
        Arrays.sort(intervals,(x, y)->x[0] - y[0]);
        int start = intervals[0][0];
        int end = intervals[0][1];
        for (int i = 1; i < intervals.length; i++){
            if (intervals[i][0] > end){
                list.add(new int[]{start, end});
                start = intervals[i][0];
                end = intervals[i][1];
            } else {
                if(intervals[i][1] > end) {
                    end = intervals[i][1];
                } 
            }
        }
        list.add(new int[]{start, end});
        int[][] res = new int[list.size()][2];
        return list.toArray(res);
    }
}
```

### 分析

题目的整体思路很直接，但是还是写错了，测试用例需要详尽一点，测试用例详尽，算法的逻辑也会更加严密。

时间复杂度：O(nlog(n))，主要在排队的地方费时。
空间复杂度：O(n)。

参考：
[合并区间](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)


## 41. 缺失的第一个正数

### 题目

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

### 题解

```
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++){
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){
                int t = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = t;
            }
        }
        for (int i = 0; i < n; i++){
            if (nums[i] != i + 1){
                return i + 1;
            }
        }
        return n + 1;
    }
}
```

### 分析

通过置换，将数字放到正确的位置，置换并不会改变数字，但是可以确定数字该有的位置，如果一个nums[i] = x,则将这个数字和num[x - 1]的位置，循环这样放置后，数组就会呈现1、2、3之类的顺序，第一个错误的位置就是最小的正数。如果每个位置都有正确的数字，说明1~n的数字都是全的，那么结果就是n+1了。
每个位置循环置换，如果nums[i] = x 大于N或者小于1，说明超出范围，跳到下一位置继续置换，如果出现num[i] == num[num[i] - 1],说明num[i] 上的数字已经是正确的数字了，这样也需要跳到下一个位置继续置换。

这个思路真是想不出来，好好把这个题目给记住吧。

时间复杂度：O(n)，至多置换n次，每次置换都会把一个数字放到正确的位置或者排除掉一个超限的数字。
空间复杂度：O(1)。

参考：
[缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/?envType=study-plan-v2&envId=top-100-liked)


## 54. 螺旋矩阵

### 题目

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

### 题解

```
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList<>();
        int l = 0;
        int r = matrix[0].length - 1;
        int u = 0;
        int d = matrix.length - 1;

        int i = 0;
        int j = 0;
        while(true){
            while(true){
                list.add(matrix[i][j]);
                if(j + 1 <= r){
                    j++;
                } else {
                    break;
                }
            }
            if (u + 1 > d){
                break;
            } else {
                u++;
                i++;
            }

            while(true){
                list.add(matrix[i][j]);
                if(i + 1 <= d){
                    i++;
                } else {
                    break;
                }
            }
            if (r - 1 < l){
                break;
            } else {
                r--;
                j--;
            }

            while(true){
                list.add(matrix[i][j]);
                if(j - 1 >= l){
                    j--;
                } else {
                    break;
                }
            }
            if (d - 1 < u){
                break;
            } else {
                d--;
                i--;
            }

            while(true){
                list.add(matrix[i][j]);
                if(i - 1 >= u){
                    i--;
                } else {
                    break;
                }
            }
            if (l + 1 > r){
                break;
            } else {
                l++;
                j++;
            }
        }
        return list;
    }
}
```

### 分析

在某外卖公司面试碰到的原题，原来做过现场也不记得了，现在还是能自己写出来了，不过思路还是得好好记记，毕竟现场的时间有限。

时间复杂度：O(n*m)。
空间复杂度：O(1)。

参考：
[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)


## 48. 旋转图像

### 题目

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

### 题解

```
class Solution {
    public void rotate(int[][] matrix) {
        for (int i = 0; i <= matrix.length / 2 -1; i++){
            for (int j = 0; j < matrix[0].length; j++){
                int t = matrix[i][j];
                matrix[i][j] = matrix[matrix.length - 1 - i][j];
                matrix[matrix.length - 1 - i][j] = t;
            }
        }
        for (int i = 1; i <= matrix.length - 1; i++){
            for (int j = 0; j < i; j++){
                int t = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = t;
            }
        }
    }
}
```

### 分析

有点脑经急转弯的题目，上下翻转，对角线翻转即可得到结果。

时间复杂度：O(n*m)。
空间复杂度：O(1)。

参考：
[旋转图像](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)


## 160. 相交链表         

### 题目

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pa = headA;
        ListNode pb = headB;
        while(!(pa == null && pb == null)){
            if (pa == null){
                pa = headB;
            }
            if (pb == null){
                pb = headA;
            }
            if (pa == pb){
                return pa;
            }
            pa = pa.next;
            pb = pb.next;
        }
        return null;
    }
}
```

### 分析

经典题目，原来做过，稍微想了一小会，好家伙，然后竟然又错了，这个null值跳转应该在比较之前就做掉才行，否则和预期的逻辑不符。

时间复杂度：O(n+m)。
空间复杂度：O(1)。

参考：
[相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&envId=top-100-liked)


## 206. 反转链表      

### 题目

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null){
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        ListNode next = head.next;
        cur.next = pre;
        while (next != null){
            pre = cur;
            cur = next;
            next = next.next;
            cur.next = pre;
        }
        return cur;

    }
}
```

### 分析

经典题目，原来做过，曾经某电商面试原题，没做出来的我尴尬得不行，这次倒是可以很快写出来，记录下用于巩固。

时间复杂度：O(n)。
空间复杂度：O(1)。

参考：
[反转链表](https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&envId=top-100-liked)

## 234. 回文链表     

### 题目

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> list = new ArrayList<>();
        list.add(head.val);
        while (head.next != null){
            head = head.next;
            list.add(head.val);
        }
        int i = 0;
        int j = list.size() - 1;
        while(i <= j){
            if (list.get(i) == list.get(j)){
                i++;
                j--;
            } else {
                return false;
            }
        }
        return true;

    }
}
```

### 分析

用O(n)的空间复杂度直接解是很简单的，O(1)的空间复杂度解法没有尝试过，个人感觉先遍历一遍计数统计出总数，然后翻转前半截链表，然后从链表中心分别向两边便利来验证回文性质，不太想写这个解法了，姑且记下思路。

时间复杂度：O(n)。
空间复杂度：O(n)。

参考：
[回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)
