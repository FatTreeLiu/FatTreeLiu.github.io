---
title: 力扣热题100做题记录
categories:
  - 面试
tags:
  - 数据结构与算法
date: 2023-12-05 22:16:55
---

# 前言

只有写出来，才是自己的，算法题也得好好做笔记。

# 记录

## 1. 两数之和（复习）

### 题目

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

### 题解

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++){
            if (map.containsKey(target - nums[i])){
                int[] res = new int[2];
                res[0] = map.get(target - nums[i]);
                res[1] = i;
                return res;
            }
            map.put(nums[i], i);
        }
        return new int[2];
    }
}
```

### 分析

官方的题解比较优雅，就是上方的题解。遍历数据，在把当前数值和索引放进map前先找是否有符合的数值，这样就可以巧妙的避免索引重复，而且效率会更高。

时间复杂度O(n)
空间复杂度O(n)

参考：
[两数之和](https://leetcode.cn/problems/two-sum/description/)

## 49. 字母异位词分组

### 题目

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

### 题解
```
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs){
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            if (map.containsKey(key)){
                map.get(key).add(str);
            } else {
                List<String> list = new ArrayList<>();
                list.add(str);
                map.put(key,list);
            }
        }
        List<List<String>> res = new ArrayList<>();
        for (Map.Entry<String,List<String>>  entry : map.entrySet()){
            res.add(entry.getValue());
        }
        return res;  
    }
}
```

### 分析

此题一次性做出来了，方法感觉很暴力，但是确实也是比较优的方案了，api有些生疏了，但是竟然磕磕绊绊写出来了。。。后续要复习，熟悉下相关的api。
一点心得，有时解题不要过于追求完美，先写出来，再写的快，再写的优美。

时间复杂度：O(nklog(k))，n为单数数量，k为单词长度，排序的复杂度是klog(k)
空间复杂度：O(nk)

参考：
[字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)

## 128. 最长连续序列

### 题目

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

### 题解

```
// 首次不超时，速度倒数9%
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length <= 1){
            return nums.length;
        }
        Set<Integer> set = new HashSet<>();
        for (int num : nums){
            set.add(num);
        }
        int res = 1;
        for (int num : nums){
            int tLen = 1;
            int p = num;
            if (set.contains(p - 1)){
                continue;
            }
            while (set.contains(p + 1)){
                tLen += 1;
                p = p + 1;
            }
            res = Math.max(res, tLen);
        }
        return res;
    }
}
```

### 分析

第一次写超时了，因为没有把set.contains(p - 1)的分支剪掉，导致重复计算了，第二次剪掉了这个分支，速度仍然只击败了9%，看来下原来的逻辑基本和这个一样，这个题目的题解姑且这样吧。

时间复杂度：O(n)-O(n^2)
空间复杂度：O(n)

参考：
[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)

## 283. 移动零(复习)

### 题目

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。

### 题解

```
// 我写了20分钟的答案
class Solution {
    public void moveZeroes(int[] nums) {
        int i = -1;
        for (int s = 0; s < nums.length; s++){
            if (nums[s] == 0){
                i = s;
                break;
            }
        }
        if (i == -1){
            return;
        }
        for (int j = i + 1; j < nums.length; j++){
            if (nums[j] != 0){
                sw(nums, i, j);
                i++;
            }
        }
    }
    public void sw(int[] nums, int i, int j){
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```

```
// 原来提交过的答案，优雅，实在是优雅
class Solution {
    public void moveZeroes(int[] nums) {
       int i = 0;
       for (int j = 0; j < nums.length; j++){
           if (nums[j] != 0){
               int t = nums[i];
               nums[i] = nums[j];
               nums[j] = t;
               i++;
           }
       }   
    }
}
```

### 分析

正确的答案总是那么优雅，好好背背吧，至少能少些几行垃圾代码

时间复杂度：O(n)
空间复杂度：O(1)

参考：
[最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked)


## 15. 三数之和（复习）

### 题目

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

### 题解
```
//又不是不能过解法
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        Set<String> set = new HashSet<>();
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < nums.length - 2; i++){
            int j = i + 1;
            int k = nums.length - 1;
            while(j < k){
                int sum = nums[j] + nums[k];
                if (sum > -nums[i]){
                    k--;
                    continue;
                }
                if (sum < -nums[i]){
                    j++;
                    continue;
                }
                String key = nums[i] + "-" + nums[j] + "-" + nums[k];
                if (!set.contains(key)){
                    set.add(key);
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[i]);
                    list.add(nums[j]);
                    list.add(nums[k]);
                    res.add(list);
                }
                j++;
            }
        }
        return res;
    }
}
```

```
//优雅一点的解法
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 0; i < nums.length - 2; i++){
            if (nums[i] > 0){
                return res;
            }
            if (i > 0 && nums[i] == nums[i - 1]){
                continue;
            }
            int j = i + 1;
            int k = nums.length - 1;
            while(j < k){
                if (j > i + 1 && nums[j] == nums[j - 1]){
                    j++;
                    continue;
                }
                if (k < nums.length - 1 && nums[k] == nums[k + 1]){
                    k--;
                    continue;
                }
                int sum = nums[j] + nums[k];
                if (sum > -nums[i]){
                    k--;
                    continue;
                }
                if (sum < -nums[i]){
                    j++;
                    continue;
                }
                Integer[] arr = new Integer[]{nums[i],nums[j],nums[k]};
                res.add(Arrays.asList(arr));
                j++;
                k--;
            }
        }
        return res;
    }
}
```

### 分析

基本的思路是排序，然后双指针夹逼，需要注意的点是结果不能重复，所以我直接采用了暴力的HashSet进行去重。但是整体流程不是那么的优雅，更加优雅的方案是前面几个值固定时，当前值去重，一但当前值有重复的，很可能导致出现重复结果，所以需要跳过。

时间复杂度：O(n^2)
空间复杂度：O(logN)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(log⁡N)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums的副本并进行排序，空间复杂度为 O(N)。

参考：
[三数之和](https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked)
[力扣题解](https://leetcode.cn/problems/3sum/)


## 560. 和为 K 的子数组（复习）

### 题目

给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。

子数组是数组中元素的连续非空序列。

### 题解
```
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        Map<Integer, Integer> map = new HashMap<>();
        int pre = 0;
        map.put(0, 1);
        for (int i = 0 ;i < nums.length; i++){
            pre = pre + nums[i];
            count += map.getOrDefault(pre - k, 0);
            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}
```

### 分析

这个题目开始以为用双指针，想复杂了，看来题解，感觉前缀和还是是优雅。真是有点东西。

时间复杂度：O(n)。
空间复杂度：O(n)。

参考：
[和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)


## 76. 最小覆盖子串（复习）

### 题目

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。

### 题解
```
class Solution {
    public String minWindow(String s, String t) {
        String str = "";
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < t.length(); i++){
            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) + 1);
        }
        int start = 0;
        int end = 0;
        map.put(s.charAt(end), map.getOrDefault(s.charAt(end), 0) - 1);
        while(end < s.length() && start <= end){
            if (hasSub(map)){
                if ("".equals(str)){
                    str = s.substring(start, end + 1);
                } else {
                    if ((end - start + 1) < str.length()){
                        str = s.substring(start, end + 1);
                    }
                }
                start++;
                map.put(s.charAt(start - 1),map.get(s.charAt(start - 1)) + 1);
                continue;
            } else {
                end++;
                if (end >= s.length()){
                    break;
                }
                map.put(s.charAt(end), map.getOrDefault(s.charAt(end), 0) - 1);
            }
        }
        return str;
    }
    public boolean hasSub(Map<Character, Integer> map){
        for (Map.Entry<Character, Integer> entry : map.entrySet()){
            if (entry.getValue() > 0){
                return false;
            }
        }
        return true;
    }
}
```

### 分析

旧笔记本坏了卖废品了，总算把新笔记本落实了，把博客环境搭建好，今天完成了笔记本坏前的一道hard题，虽然是hard，实际解题思路还是比较简单的，总体来说就是滑动窗口。
运行了几次都没有通过，仔细检查了下其实是String的substring(int start, int end)方法没有用对，这个方法包含start但是不包含end，所以end需要注意是否需要加1.


时间复杂度：O(n)，无论是start还是end，最多滑动一遍。
空间复杂度：O(n)。用到了Hashmap。

参考：
[最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked)


## 56. 合并区间（复习）

### 题目

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

### 题解
```
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> list = new ArrayList<>();
        Arrays.sort(intervals,(x, y)->x[0] - y[0]);
        int start = intervals[0][0];
        int end = intervals[0][1];
        for (int i = 1; i < intervals.length; i++){
            if (intervals[i][0] > end){
                list.add(new int[]{start, end});
                start = intervals[i][0];
                end = intervals[i][1];
            } else {
                if(intervals[i][1] > end) {
                    end = intervals[i][1];
                } 
            }
        }
        list.add(new int[]{start, end});
        int[][] res = new int[list.size()][2];
        return list.toArray(res);
    }
}
```

### 分析

题目的整体思路很直接，但是还是写错了，测试用例需要详尽一点，测试用例详尽，算法的逻辑也会更加严密。

时间复杂度：O(nlog(n))，主要在排队的地方费时。
空间复杂度：O(n)。

参考：
[合并区间](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)


## 41. 缺失的第一个正数（复习）

### 题目

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

### 题解

```
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++){
            while(nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){
                int t = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = t;
            }
        }
        for (int i = 0; i < n; i++){
            if (nums[i] != i + 1){
                return i + 1;
            }
        }
        return n + 1;
    }
}
```

### 分析

通过置换，将数字放到正确的位置，置换并不会改变数字，但是可以确定数字该有的位置，如果一个nums[i] = x,则将这个数字和num[x - 1]的位置，循环这样放置后，数组就会呈现1、2、3之类的顺序，第一个错误的位置就是最小的正数。如果每个位置都有正确的数字，说明1~n的数字都是全的，那么结果就是n+1了。
每个位置循环置换，如果nums[i] = x 大于N或者小于1，说明超出范围，跳到下一位置继续置换，如果出现num[i] == num[num[i] - 1],说明num[i] 上的数字已经是正确的数字了，这样也需要跳到下一个位置继续置换。

这个思路真是想不出来，好好把这个题目给记住吧。

时间复杂度：O(n)，至多置换n次，每次置换都会把一个数字放到正确的位置或者排除掉一个超限的数字。
空间复杂度：O(1)。

参考：
[缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/?envType=study-plan-v2&envId=top-100-liked)


## 54. 螺旋矩阵（复习）

### 题目

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

### 题解

```
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> list = new ArrayList<>();
        int t = 0;
        int d = matrix.length - 1;
        int l = 0;
        int r = matrix[0].length - 1;
        while (true){
            if (l <= r){
                for (int j = l; j <= r; j++){
                    list.add(matrix[t][j]);
                }
                t++;
            } else {
                break;
            }
            if (t <= d){
                for (int i = t; i <= d; i++){
                    list.add(matrix[i][r]);
            }
            }
            if (r - 1 < l){
                break;
            } else {
                }
            if (r - 1 < l){
                break;
            } else {
                r--;
            } else {
                break;
            }
            if (l <= r){
                for (int j = r; j >= l; j--){
                    list.add(matrix[d][j]);
            }
            }
            if (d - 1 < u){
                break;
            } else {
                }
            if (d - 1 < u){
                break;
            } else {
                d--;
            } else {
                break;
            }
            if (t <= d){
                for (int i = d; i>= t; i--){
                    list.add(matrix[i][l]);
                }
                l++;
            } else {
                break;
            }
        }
        return list;

    }
}
```

### 分析

收缩边界，本体直接用边界的坐标进行遍历即可。

时间复杂度：O(n*m)。
空间复杂度：O(1)。

参考：
[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)


## 48. 旋转图像

### 题目

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

### 题解

```
class Solution {
    public void rotate(int[][] matrix) {
        for (int i = 0; i <= matrix.length / 2 -1; i++){
            for (int j = 0; j < matrix[0].length; j++){
                int t = matrix[i][j];
                matrix[i][j] = matrix[matrix.length - 1 - i][j];
                matrix[matrix.length - 1 - i][j] = t;
            }
        }
        for (int i = 1; i <= matrix.length - 1; i++){
            for (int j = 0; j < i; j++){
                int t = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = t;
            }
        }
    }
}
```

### 分析

有点脑经急转弯的题目，上下翻转，对角线翻转即可得到结果。

时间复杂度：O(n*m)。
空间复杂度：O(1)。

参考：
[旋转图像](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)


## 160. 相交链表（复习）         

### 题目

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pa = headA;
        ListNode pb = headB;
        while(!(pa == null && pb == null)){
            if (pa == null){
                pa = headB;
            }
            if (pb == null){
                pb = headA;
            }
            if (pa == pb){
                return pa;
            }
            pa = pa.next;
            pb = pb.next;
        }
        return null;
    }
}
```

### 分析

经典题目，原来做过，稍微想了一小会，好家伙，然后竟然又错了，这个null值跳转应该在比较之前就做掉才行，否则和预期的逻辑不符。

时间复杂度：O(n+m)。
空间复杂度：O(1)。

参考：
[相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&envId=top-100-liked)


## 206. 反转链表（复习）      

### 题目

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

### 题解

```
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null){
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        while (cur.next != null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        cur.next = pre;
        return cur;
    }
}
```

### 分析

经典题目，原来做过，曾经某电商面试原题，没做出来的我尴尬得不行，这次倒是可以很快写出来，记录下用于巩固。

时间复杂度：O(n)。
空间复杂度：O(1)。

参考：
[反转链表](https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&envId=top-100-liked)

## 234. 回文链表     

### 题目

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> list = new ArrayList<>();
        list.add(head.val);
        while (head.next != null){
            head = head.next;
            list.add(head.val);
        }
        int i = 0;
        int j = list.size() - 1;
        while(i <= j){
            if (list.get(i) == list.get(j)){
                i++;
                j--;
            } else {
                return false;
            }
        }
        return true;

    }
}
```

### 分析

用O(n)的空间复杂度直接解是很简单的，O(1)的空间复杂度解法没有尝试过，个人感觉先遍历一遍计数统计出总数，然后翻转前半截链表，然后从链表中心分别向两边便利来验证回文性质，不太想写这个解法了，姑且记下思路。

时间复杂度：O(n)。
空间复杂度：O(n)。

参考：
[回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked)


## 21. 合并两个有序链表  

### 题目

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null){
            return list2;
        }
        if (list2 == null){
            return list1;
        }
        ListNode head = null;
        if (list2.val > list1.val){
            head = list1;
            list1 = list1.next;
        } else {
            head = list2;
            list2 = list2.next;
        }
        ListNode p = head;
        while (list1 != null && list2 != null){
            if (list2.val > list1.val){
                p.next = list1;
                list1 = list1.next;
            } else {
                p.next = list2;
                list2 = list2.next;
            }
            p = p.next;
        }
        if (list1 == null){
            p.next = list2;
        } else {
            p.next = list1;
        }
        return head;
    }
}
```

### 分析

做题时误把指针当成头节点了~

时间复杂度：O(n + m)。
空间复杂度：O(1)。

参考：
[合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked)


## 2. 两数相加（复习）

### 题目

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

### 题解

```
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode vh = new ListNode();
        ListNode vp = vh;
        int a = 0;
        while (l1 != null || l2 != null || a != 0){
            if (l1 != null && l2 != null){
                int c = (l1.val + l2.val + a) % 10;
                a = (l1.val + l2.val + a) / 10;
                vp.next = new ListNode(c);
                vp = vp.next;
                l1 = l1.next;
                l2 = l2.next;
                continue;
            }
            if (l1 != null){
                int c = (l1.val + a) % 10;
                a = (l1.val + a) / 10;
                vp.next = new ListNode(c);
                vp = vp.next;
                l1 = l1.next;
                continue;
            }
            if (l2 != null){
                int c = (l2.val + a) % 10;
                a = (l2.val + a) / 10;
                vp.next = new ListNode(c);
                vp = vp.next;
                l2 = l2.next;
                continue;
            }
            if (l1 == null && l2 == null && a != 0){
                int c = a % 10;
                a = a / 10;
                vp.next = new ListNode(c);
                vp = vp.next;
                continue;
            }
        }
        return vh.next;
    }
}
```

### 分析

这版写的很清晰

时间复杂度：O(n + m)。
空间复杂度：O(1)。

参考：
[两数相加](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-100-liked)


## 19. 删除链表的倒数第 N 个结点

### 题目

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int count = 0;
        ListNode p = head;
        while(p != null){
            count++;
            p = p.next;
        }
        if (n > count){
            return null;
        }
        if (n == count){
            return head.next;
        }
        p = head;
        int idx = count;
        while(idx != n + 1){
            p = p.next;
            idx--;
        }
        p.next = p.next.next;
        return head;
    }
}
```

### 分析

可以再炫一遍。

时间复杂度：O(n)。
空间复杂度：O(1)。

参考：
[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked)


## 24. 两两交换链表中的节点（复习）

### 题目

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

### 题解

```
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode vh = new ListNode();
        ListNode p = vh;
        while (true){
            if (head == null){
                return vh.next;
            }
            if (head != null && head.next == null){
                p.next = head;
                return vh.next;
            }
            ListNode t = head.next;
            head.next = t.next;
            t.next = head;
            p.next = t;
            p = head;
            head = head.next;
        }
    }
}
```

### 分析

node1和node2的顺序会改变，直接用这两个指针会有点麻烦，所以直接又创建了指针p，为了方便又创建一个虚拟头节点。

时间复杂度：O(n)。
空间复杂度：O(1)。

参考：
[两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)


## 25. K 个一组翻转链表

### 题目

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

### 题解

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode z = new ListNode(0);
        ListNode p = z;
        ListNode start = head;
        while(start != null){
            ListNode tp = start;
            int tc = 0;
            while(tp != null && tc < k){
                tc++;
                tp = tp.next;
            }
            if (tc < k){
                p.next = start;
                return z.next;
            }
            int c = 1;
            ListNode pre = null;
            ListNode cur = start;
            ListNode next = start.next;
            cur.next = pre;
            while (next != null && c < k){
                c++;
                pre = cur;
                cur = next;
                next = next.next;
                cur.next = pre;
            }
            p.next = cur;
            p = start;
            start = next;
        }
        return z.next;
    }
}
```

### 分析

和双双交换链表元素类似，也是设置一个虚拟头节点，然后分组进行链表翻转，恶心的是需要保证最后一组不足k的链表不翻转，为了偷懒在每个翻转前加了一个检查，如果要好好写的话，还是最后发现不足k的时候再翻转会效率高点。

时间复杂度：O(n)。
空间复杂度：O(1)。

参考：
[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-100-liked)


## 146. LRU 缓存（复习）

### 题目

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

### 题解

工程中的写法（偷懒的写法）

```
class LRUCache extends LinkedHashMap<Integer, Integer>{
    // private修饰
    private int capacity;
    /**
     * 当LinkedHashMap的accessOrder参数为true时，即会按照访问顺序排序，最近访问的放在最前，最早访问的放在后面
     */
    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }
    
    /**
     * LinkedHashMap自带的判断是否删除最老的元素方法，默认返回false，即不删除老数据，size()是方法
     */
    public boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest){
        return size() > capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }
    
    public void put(int key, int value) {
        super.put(key, value);
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

### 分析

原来正儿八经写过双向链表结合hashmap的，实在是很难写，思路不难，但是极易写错，这次不写了，直接把基于LinkedHashMap的记住吧。
为什么必须使用双向的链表？双向链表保证了删除尾节点后在O(1)时间内找到尾结点的前一个作为新的尾结点。

时间复杂度：O(1)。
空间复杂度：O(n)。

参考：
[LRU 缓存](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)


## 543. 二叉树的直径（复习）

### 题目

给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。

### 题解

```
class Solution {
    int res = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDep(root);
        return res;
    }
    public int maxDep(TreeNode root){
        if (root == null){
            return 0;
        }
        int left = maxDep(root.left);
        int right = maxDep(root.right);
        res = Math.max(res, left + right );
        return Math.max(left, right) + 1;
    }
}
```

### 分析

在求最大深度的过程中进行计算，顺带计算的中间变量。

时间复杂度：O(n)。
空间复杂度：O(1)。

参考：
[二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)


## 98. 验证二叉搜索树（复习）

### 题目

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

### 题解

```
class Solution {
    Integer pre = null;
    boolean isStop = false;
    boolean res = true;
    public boolean isValidBST(TreeNode root) {
        dfs(root);
        return res;
    }
    public void dfs(TreeNode root){
        if (root == null || isStop){
            return;
        }
        dfs(root.left);
        if (pre == null){
            pre = root.val;
        } else {
            if (pre < root.val){
                pre = root.val;
            } else {
                res = false;
                isStop = true;
            }
        }
        dfs(root.right);
    }
}
```

### 分析

中根遍历，用包装类解决初始化的问题，增加停止标识进行剪枝。

时间复杂度：O(n)。
空间复杂度：方法1:栈深度O(n)

参考：
[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)


## 230. 二叉搜索树中第K小的元素（复习）

### 题目

给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。

### 题解


```
class Solution {
    Integer res = null;
    int count = 0;
    boolean stopf = false;
    public int kthSmallest(TreeNode root, int k) {
        count = k;
        dfs(root);
        return res;
    }
    public void dfs(TreeNode root){
        if (root == null || stopf){
            return;
        }
        dfs(root.left);
        if (stopf){
            return;
        }
        res = root.val;
        count--;
        if (count == 0){
            stopf = true;
        }
        dfs(root.right);
    }
}
```

### 分析

注意遍历中中根的时候还需要再检查剪一次，因为前面的子树遍历完可能已经达到终止条件了。

时间复杂度：O(n)。
空间复杂度：栈深度O(n)，最坏为n，树退化为链表

参考：
[二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)


## 105. 从前序与中序遍历序列构造二叉树（复习）

### 题目

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

### 题解

```
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    int[] preorder;
    int[] inorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        for (int i = 0; i < inorder.length; i++){
            map.put(inorder[i], i);
        }
        return dfs(0, preorder.length - 1, 0, inorder.length - 1);
    }
    public TreeNode dfs(int pl, int pr, int il, int ir){
        if (pl > pr || il > ir){
            return null;
        }
        TreeNode root = new TreeNode(preorder[pl]);
        int iix = map.get(preorder[pl]);
        root.left = dfs(pl + 1, pl + iix - il, il, iix - 1);
        root.right = dfs(pl + iix - il + 1, pr, iix + 1, ir);
        return root;
    }
}
```

### 分析

一个map加速定位根坐标，四个坐标确定边界，通过子树长度辅助确定边界。

时间复杂度：O(n)
空间复杂度：O(n)

参考：
[从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)


## 437. 路径总和 III（复习）

### 题目

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

### 题解

枚举法

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }

        int ret = rootSum(root, (long)targetSum);
        ret += pathSum(root.left, targetSum);
        ret += pathSum(root.right, targetSum);
        return ret;
    }

    public int rootSum(TreeNode root, long targetSum) {
        int ret = 0;

        if (root == null) {
            return 0;
        }
        long val = (long)root.val;
        if (val == targetSum) {
            ret++;
        } 

        ret += rootSum(root.left, targetSum - val);
        ret += rootSum(root.right, targetSum - val);
        return ret;
    }

}
```

前缀和

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
       public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> map = new HashMap<>();
        map.put(0L,1);
        return rootSum(root, map, targetSum, 0L);
    }

    public int rootSum(TreeNode root, Map<Long, Integer> map,  int targetSum, long sum) {
        int res = 0;
        if (root == null) {
            return 0;
        }
        sum = sum + root.val;
        res += map.getOrDefault(sum - targetSum, 0);
        map.put(sum, map.getOrDefault(sum, 0) + 1);
        res += rootSum(root.left, map, targetSum, sum);
        res += rootSum(root.right, map, targetSum, sum);
        map.put(sum, map.get(sum) - 1);
        return res;
    }
}
```

### 分析

枚举法：
时间复杂度：O(n^2)
空间复杂度：O(n)，二叉树最坏的情况，树深度等于n

前缀和：
时间复杂度：O(n)
空间复杂度：O(n)

枚举法是以某个节点出发，分别有多少个目标路径，然后求和，这样对每个节点均需要再便利一次，时间复杂度较高
前缀和是计算以某个节点为结尾，分别有多少个目标路径，因为用了前缀和，对于每个点可以以O(1)的复杂度获取路径数，整体时间复杂度较低。前缀和加回溯掉的一批。大数的那个用例略撒比。

参考：
[路径总和 III](https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked)


## 124. 二叉树中的最大路径和

### 题目

二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

### 题解

```
class Solution {
    int res = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return res;
    }
    public int dfs(TreeNode root){
        if (root == null){
            return 0;
        }
        int leftG = Math.max(dfs(root.left), 0);
        int rightG =Math.max(dfs(root.right), 0);
        res = Math.max(res, root.val + leftG + rightG);
        return root.val + Math.max(leftG, rightG);
    }
}
```

### 分析

时间复杂度：O(n)
空间复杂度：O(n)

路径为节点值加左边加右边，贡献值G是节点值加左边或右边的贡献值，贡献值最低为0

参考：
[二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)


## 207. 课程表（复习）

### 题目

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

### 题解

```
// 注意，本题课程编号从0到numCourses-1，所以记录的时候直接基于数组和列表即可，不用map
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 入度表，表示每个节点直接依赖了几个节点，如果直接依赖的节点学习了，那么这里的入度可以减一
        int[] inDegree = new int[numCourses];
        // 邻接表，表示每个节点后续直接关联的节点，如果当前节点学习了，那么就可以通知后续节点的入度分别减一
        List<List<Integer>> ad = new ArrayList<>();
        // 初始化邻接表
        for (int i = 0; i < numCourses; i++){
            ad.add(new ArrayList<>());
        }
        // 计算入度表，计算邻接表
        for (int[] c : prerequisites){
            inDegree[c[0]] = inDegree[c[0]] + 1;
            ad.get(c[1]).add(c[0]);
        }
        // bfs需要的队列
        Queue<Integer> queue = new LinkedList<>();
        // 把入度为0的节点先放到队列里去，这些节点不依赖任何节点，可以先学习
        for (int i = 0; i < numCourses; i++){
            if (inDegree[i] == 0){
                queue.add(i);
            }
        }

        while(!queue.isEmpty()){
            // 完成一个节点的学习
            int pre = queue.poll();
            // 这样剩余的课程就少了一个
            numCourses--;
            // 因为完成了一个节点的学习，那么这个节点在邻接表里的后续节点都可以减少一个入度
            for (int i : ad.get(pre)){
                // 如果节点的入度减少为0时，说明该节点的前置节点都学完了，这个节点也加入到队列中，准备学习，循环起来
                if (--inDegree[i] == 0){
                    queue.add(i);
                }
            }
        }
        // 学到最后，所有入度为0的节点都学习完了，剩下的节点的入度都不为0，即任何一个节点都有前置节点，明显是有循环依赖
        // 学习完成的节点都减去了，如果剩余的节点不为0，说明有循环依赖
        return numCourses == 0;
    }
}
```

### 分析

这个题目有点复杂了。
学一个节点，减掉一个入度，相当于去掉了这个节点和边，所有的节点和边都要遍历，节点数为m，边数为n
邻接表因为有m个节点，所以有m个列表，每个列表里包含的元素表示边数，共计n
时间复杂度：O(n + m)
空间复杂度：O(n + m)

参考：
[课程表](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-100-liked)


## 994. 腐烂的橘子

### 题目

在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。

返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。

### 题解

```
class Solution {
    public int orangesRotting(int[][] grid) {
        int count = 0;
        Queue<int[]> queue = new LinkedList<>();
        int M = grid.length;
        int N = grid[0].length;
        // 把烂橘子加入队列，同时统计好橘子数
        for (int i = 0; i < M; i++){
            for (int j = 0; j < N; j++){
                if(grid[i][j] == 1){
                    count++;
                }
                if (grid[i][j] == 2){
                    queue.add(new int[]{i, j});
                }
            }
        }

        int res = 0;
        while (count > 0 && !queue.isEmpty()){
            // 统计轮数
            res++;
            int size = queue.size();
            for (int i = 0; i < size; i++){
                int[] p = queue.poll();
                int r = p[0];
                int c = p[1];
                if ((r - 1) >= 0 && grid[r-1][c] == 1){
                    grid[r - 1][c] = 2;
                    count--;
                    queue.add(new int[]{r - 1, c});
                }
                if ((r + 1) < M && grid[r + 1][c] == 1){
                    grid[r + 1][c] = 2;
                    count--;
                    queue.add(new int[]{r + 1, c});
                }
                if ((c - 1) >= 0 && grid[r][c - 1] == 1){
                    grid[r][c - 1] = 2;
                    count--;
                    queue.add(new int[]{r, c - 1});
                }
                if ((c + 1) < N && grid[r][c + 1] == 1){
                    grid[r][c + 1] = 2;
                    count--;
                    queue.add(new int[]{r, c + 1});
                }
            }
        }
        // 能烂的都烂完了，如果还有好橘子，说明无法完成
        if (count == 0){
            return res;
        } else {
            return -1;
        }

    }
}
```

### 分析

开始想的是，从每个烂橘子团分别开始BFS，同时还要考虑是否存在独立的好橘子团，这样考虑下来十分复杂，直接想跳过这个题目，但是看到题解后感觉十分优雅。
其实不用分别从每个烂橘子团分别开始，可以把所有的烂橘子都加进队列，一起开始bfs，这样也是符合实际情况的。
另外轮迭代要统计轮数，这个就是烂完所需要的时间。
另外如果存在好橘子团怎么办，这里需要提前统计好橘子数，当能烂的橘子都烂了，剩下的好橘子数量大于0，说明无法烂完。

时间复杂度：O(n)
空间复杂度：O(n)

参考：
[腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked)


## 208. 实现 Trie (前缀树)（复习）

### 题目

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

### 题解

```
class Trie {
    Trie[] child;
    boolean isEnd;

    public Trie() {
        child = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); i++){
            char c = word.charAt(i);
            int ix = c - 'a';
            if (node.child[ix] == null){
                node.child[ix] = new Trie();
            }
            node = node.child[ix];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchWithPrefix(word);
        return node != null &&  node.isEnd == true;

    }
    
    public boolean startsWith(String prefix) {
       return searchWithPrefix(prefix) != null;
    }

    public Trie searchWithPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); i++){
            char c = prefix.charAt(i);
            int ix = c - 'a';
            if (node.child[ix] == null){
                return null;
            }
            node = node.child[ix];
        }
        return node;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

### 分析

前缀树的模板解法，多做几遍记住，其实并不难

参考：
[实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)


## 46. 全排列（复习）

### 题目

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

### 题解

```
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    int[] nums;
    boolean[] flags;
    public List<List<Integer>> permute(int[] nums) {
        this.nums = nums;
        this.flags = new boolean[nums.length];
        List<Integer> list = new ArrayList<>();
        dfs(list);
        return res;
    }
    public void dfs(List<Integer> list){
        if (list.size() == nums.length){
            List<Integer> tl = new ArrayList<>();
            for (int num : list){
                tl.add(num);
            }
            res.add(tl);
        }
        for (int i = 0; i < nums.length; i++){
            if (flags[i]){
                continue;
            }
            list.add(nums[i]);
            flags[i] = true;
            dfs(list);
            flags[i] = false;
            list.remove(list.size() - 1);
        }
    }
}
```

### 分析

回溯的题目都有重做的必要性

时间复杂度：O(n·n!),backtrack的调用次数是O(n!)的,调用的每个叶结点我们需要将当前答案使用O(n)的时间复制到答案数组中，相乘得时间复杂度为O(n·n!)
空间复杂度：O(n)

参考：
[全排列](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)


## 78. 子集（复习）

### 题目

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

### 题解

```
class Solution {
    int[] nums;
    List<List<Integer>> res;
    public List<List<Integer>> subsets(int[] nums) {
        this.nums = nums;
        this.res = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(0, list);
        return res;
    }   
    public void dfs(int idx, List<Integer> list){
        if (idx >= nums.length){
            res.add(new ArrayList(list));
            return;
        }
        list.add(nums[idx]);
        dfs(idx+1, list);
        list.remove(list.size() - 1);
        dfs(idx+1, list);
    }
    
}
```

### 分析

按照顺序，加入或者不加入dfs，可以得到所有的子集

时间复杂度：O(n·2^n)。共有2^n个状态，每个状态构造过程为O(n)
空间复杂度：O(n)，栈深度和临时数组的长度。

参考：
[子集](https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked)


## 17. 电话号码的字母组合

### 题目

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

### 题解

```
class Solution {
    Map<Character, char[]> map;
    List<String> res = new ArrayList<>();
    String digits;
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0){
            return res;
        }
        this.digits = digits;
        this.map = new HashMap<>();
        map.put('2', new char[]{'a','b','c'});
        map.put('3', new char[]{'d','e','f'});
        map.put('4', new char[]{'g','h','i'});
        map.put('5', new char[]{'j','k','l'});
        map.put('6', new char[]{'m','n','o'});
        map.put('7', new char[]{'p','q','r','s'});
        map.put('8', new char[]{'t','u','v'});
        map.put('9', new char[]{'w','x','y','z'});
        StringBuilder sb = new StringBuilder();
        dfs(0, sb);
        return res;
    }
    public void dfs(int idx, StringBuilder sb){
        if (idx == digits.length()){
            res.add(sb.toString());
            return;
        }
        for (char c : map.get(digits.charAt(idx))){
            sb.append(c);
            dfs(idx + 1, sb);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
```

### 分析

不太可能会考的题目，map和数组的初始化方式需要记下，重复复习一遍就可以了

时间复杂度：O(3^m·4^n)。其中m是输入中对应3个字母的数字个数，n是输入中对应4个字母的数字个数
空间复杂度：O(m + n)。栈深度。

参考：
[电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-100-liked)


## 39. 组合总和（复习）

### 题目

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

### 题解

```
class Solution {
    List<List<Integer>> res;
    int target;
    int[] candidates;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<>();
        this.target = target;
        this.candidates = candidates;
        dfs(0, 0, new ArrayList<>());
        return res;
    }
    public void dfs(int idx, int sum, List<Integer> list){
        if (sum > target){
            return;
        }
        if (sum == target){
            res.add(new ArrayList<>(list));
            return;
        }
        if (idx == candidates.length){
            return;
        }
        list.add(candidates[idx]);
        dfs(idx, sum + candidates[idx], list);
        list.remove(list.size() - 1);
        dfs(idx + 1, sum, list);
    }
}
```

### 分析

一个分支一只加当前元素，一个分支跳过当前元素

复杂度不太好算，懒了，不算了

参考：
[组合总和](https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&envId=top-100-liked)


## 22. 括号生成（复习）

### 题目

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

### 题解

```
class Solution {
    List<String> res = new ArrayList<>();
    int n = 0;
    public List<String> generateParenthesis(int n) {
        this.n = n;
        StringBuilder sb = new StringBuilder("(");
        dfs(1, 0, sb);
        return res;
    }
    public void dfs(int l, int r, StringBuilder sb){
        if (r > l || l + r > 2 * n){
            return;
        }
        if (l + r == 2 * n && r == l){
            res.add(sb.toString());
            return;
        }
        sb.append("(");
        l++;
        dfs(l, r, sb);
        l--;
        sb.deleteCharAt(sb.length() - 1);
        sb.append(")");
        r++;
        dfs(l, r, sb);
        r--;
        sb.deleteCharAt(sb.length() - 1);
    }
}
```

### 分析

就回溯的方法而言，这个题目不算难，这个题目难在对于括号终止条件的判断，有三个情况会终止，right > left 、 (right + left) > 2 * n 、 (left + right) == 2 * n && left == right。
这个终止条件的总结类似于业务知识，如果没有独到的分析能力，业务知识还是好好背背吧。

回溯问题的复杂度太难想了，放弃思考了。

参考：
[括号生成](https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)


## 131. 分割回文串(复习)

### 题目

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。

### 题解

```
class Solution {
    List<List<String>> res = new ArrayList<>();
    String s;
    public List<List<String>> partition(String s) {
        this.s = s;
        List<String> list = new ArrayList<>();
        dfs(list, 0);
        return res;
    }
    public void dfs(List<String> list, int start){
        if (start >= s.length()){
            res.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < s.length(); i++){
            if (test(start, i)){
                list.add(s.substring(start, i + 1));
                dfs(list, i + 1);
                list.remove(list.size() - 1);
            }
        }
    }
    public boolean test(int i, int j){
        while(i <= j){
            if (s.charAt(i) != s.charAt(j)){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}
```

### 分析

从头开始，找到每个回文字符串加入列表中迭代寻找，另外需要回溯

参考：
[分割回文串](https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked)


## 35. 搜索插入位置（复习）

### 题目

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

### 题解

```
class Solution {
    int[] nums;
    int target;
    public int searchInsert(int[] nums, int target) {
        this.nums = nums;
        this.target = target;
        if (target > nums[nums.length - 1]){
            return nums.length;
        }
        return find(0, nums.length - 1);
    }

    public int find(int left, int right){
        while (left < right){
            int mid = (left + right) / 2;
            if (nums[mid] < target){
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return right;
    }
}
```

### 分析

如果nums[mid] < target，则mid绝不可能成为解，所以left=mid+1，如果nums[mid] >= target，mid可能成为解，所以right=mid，因为推出条件为right == left，所以返回任意一个都可以。

参考：
[搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-100-liked)


## 34. 在排序数组中查找元素的第一个和最后一个位置（复习）

### 题目

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

### 题解

```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0){
            return new int[]{-1, -1};
        }
        int i = 0;
        int j = nums.length - 1;
        while (i < j){
            int mid = (i + j) / 2;
            if (nums[mid] < target){
                i = mid + 1;
            } else {
                j = mid;
            }
        }
        if (nums[i] != target){
            return new int[]{-1, -1};
        }
        int start = i;
        i = 0;
        j = nums.length - 1;
        while (i < j){
            int mid = (i + j) / 2 + 1;
            if (nums[mid] > target){
                j = mid - 1;
            } else {
                i = mid;
            }
        }
        int end = i;
        return new int[]{start, end};
    }
}
```

### 分析

找大于等于某数的第一个数字索引，用int mid = (i + j) / 2，找小于等于某数的第一个数字索引，用int mid = (i + j) / 2 + 1，否则会死循环，另外找到后判断下是否是等于目标值，如果不等说明找不到。

时间复杂度：O(log n) 
空间复杂度：O(1)

参考：
[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)


## 51. N 皇后

### 题目

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

### 题解

```
class Solution {
    char[][] nQueens;
    boolean[] colUsed;
    boolean[] d45Used;
    boolean[] d135Used;
    int n;
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        this.n = n;
        nQueens = new char[n][n];
        colUsed = new boolean[n];
        d135Used = new boolean[2 * n - 1];
        d45Used = new boolean[2 * n - 1];
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                nQueens[i][j] = '.';
            }
        }
        dfs(0);
        return res;
    }
    public void dfs(int r){
        if (r == n){
            List<String> list = new ArrayList<>();
            for (int i = 0; i < n; i++){
                list.add(new String(nQueens[i]));
            }
            res.add(list);
        }
        for (int c = 0; c < n; c++){
            if (colUsed[c] || d45Used[r + c] || d135Used[n - 1 - (r -c)]){
                continue;
            }
            nQueens[r][c] = 'Q';
            colUsed[c] = true;
            d135Used[n - 1 - (r -c)] = true;
            d45Used[r + c] = true;
            dfs(r + 1);
            colUsed[c] = false;
            d135Used[n - 1 - (r -c)] = false;
            d45Used[r + c] = false;
            nQueens[r][c] = '.';
        }
    }
}
```

### 分析

从三个角度进行约束，留一个角度进行dfs，每一层依次找到合适的位置进行下一层遍历，因为必然有n的皇后，所以必然会遍历到最后一层。
n - 1 - (r -c) 可以进行归纳，同一行从左往右，层数增加，说明和c正相关，系数为1，同理向上走，和r负相关，系数为1，可以得到+c-r，前面的n - 1可以归纳得到。

参考：
[N 皇后](https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&envId=top-100-liked)
[CS-Notes 面试笔记](https://www.cyc2018.xyz/)


## 33. 搜索旋转排序数组(复习)

### 题目

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

### 题解

```
class Solution {
    public int search(int[] nums, int target) {
        int i = 0;
        int j = nums.length - 1;
        while(i < j){
            int mid = (i + j) / 2;
            if (nums[mid] == target){
                return mid;
            }
            if (nums[mid] > nums[j]){
                if (target <= nums[j]){
                    i = mid + 1;
                }else{
                    if (nums[mid] < target){
                        i = mid + 1;
                    } else {
                        j = mid - 1;
                    }
                }
            } else {
                if (target > nums[j]){
                    j = mid - 1;
                } else {
                    if (nums[mid] < target){
                        i = mid + 1;
                    } else {
                        j = mid - 1;
                    }
                }
            }
        }
        return nums[i] == target ? i : -1;
    }
}
```

### 分析

首先观察数组，最小的数字始终在右半边，所以可以认定右半边一直存在，所以每次mid都和nums[j]比较，确定mid在左半边还是右半边，同理target也是和nums[j]比较，如果mid和target在异侧，直接确定i或者j即可，如果在同侧，继续比较nums[mid]和target，然后再确定i或者j。最后需要看nums[i]是否和target相等，如不等说明没找到。

参考：
[搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-100-liked)


## 153. 寻找旋转排序数组中的最小值（复习）

### 题目

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

### 题解

```
class Solution {
    public int findMin(int[] nums) {
        int i = 0;
        int j = nums.length - 1;
        while (i < j){
            int mid = (i + j) / 2;
            if (nums[mid] <= nums[j]){
                j = mid;
            } else {
                i = mid + 1;
            }
        }
        return nums[i];
    }
}
```

### 分析

因为找最小的数字，可以认为右边的数组是一直存在的

参考：
[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-100-liked)


## 4. 寻找两个正序数组的中位数（复习）

### 题目

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

### 题解

```
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length;
        int length2 = nums2.length;
        int length = length1 + length2;
        if (length % 2 == 1){
            return (double)findK(nums1, nums2, length / 2 + 1);
        } else {
            return (findK(nums1, nums2, length / 2) + findK(nums1, nums2, (length / 2) + 1)) / 2.0;
        }
    }

    public int findK(int[] nums1, int[] nums2, int k){
        int idx1 = 0;
        int idx2 = 0;
        int length1 = nums1.length;
        int length2 = nums2.length;
        while (true){
            if (idx1 == length1){
                return nums2[idx2 + k - 1];
            }
            if (idx2 == length2){
                return nums1[idx1 + k - 1];
            }
            if (k == 1){
                return Math.min(nums1[idx1], nums2[idx2]);
            }
            int half = k / 2;
            int newIdx1 = Math.min(idx1 + half, length1) - 1;
            int newIdx2 = Math.min(idx2 + half, length2) - 1;
            int val1 = nums1[newIdx1];
            int val2 = nums2[newIdx2];
            if (val1 <= val2){
                k -= (newIdx1 - idx1 + 1);
                idx1 = newIdx1 + 1;
            } else {
                k -= (newIdx2 - idx2 + 1);
                idx2 = newIdx2 + 1;
            }
        }

    }
}
```

### 分析

转化为找两个数组中第k个元素，如果两个数组长度和为奇数，找一次就行，如果是偶数，需要找两次。
取A的k/2-1位置的元素和B的k/2-1元素进行对比，去掉较小元素数组前面的元素，最多可以去掉k/2-2个元素，如果也去掉较小元素，则可以去掉k/2-1个元素，这样可以实现二分的效果。
需要注意的是，k是随时变化的，各列表的索引也是变化的，如果一个列表到末端了，则直接找另一个列表的第k个元素即可（注意，每次去掉都会把索引所在的元素去掉，所以找第k个，也是需要-1的，类似于idx2 + k - 1），如果k为1了，直接找两个数组中第一个元素较小的即可。

参考：
[寻找两个有序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-100-liked)


## 20. 有效的括号

### 题目

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。

### 题解

```
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<>();
        map.put(')','(');
        map.put(']','[');
        map.put('}','{');
        Deque<Character> stack = new LinkedList<>();
        for (int i = 0; i < s.length(); i++){
            char c = s.charAt(i);
            if (!map.keySet().contains(c)){
                stack.addLast(c);
            } else {
                if (stack.size() == 0){
                    return false;
                }
                char last = stack.removeLast();
                if (last != map.get(c)){
                    return false;
                }
            }
        }
        return stack.size() == 0;
    }
}
```

### 分析

细节容易出错，需要再练习下

参考：
[有效的括号](https://leetcode.cn/problems/valid-parentheses/?envType=study-plan-v2&envId=top-100-liked)


## 155. 最小栈（复习）

### 题目

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。

### 题解

```
class MinStack {
    Deque<Integer> ns = new LinkedList<>();
    Deque<Integer> ms = new LinkedList<>();

    public MinStack() {

    }
    
    public void push(int val) {
        ns.addLast(val);
        if (ms.size() == 0 || ms.peekLast() >= val){
            ms.addLast(val);
        }
    }
    
    public void pop() {
        int top = ns.removeLast();
        if (top == ms.peekLast()){
            ms.removeLast();
        }
    }
    
    public int top() {
        return ns.peekLast();
    }
    
    public int getMin() {
        return ms.peekLast();
    }
}
```

### 分析

维持两个栈，一个正常栈，一个最小栈

参考：
[最小栈](https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-100-liked)


## 394. 字符串解码(复习)

### 题目

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

### 题解

```
class Solution {
    public String decodeString(String s) {
        StringBuilder res = new StringBuilder();
        Integer multi = 0;
        Deque<Integer> multiStack = new LinkedList<>();
        Deque<String> resStack = new LinkedList<>();
        for (Character c : s.toCharArray()){
            if (c == '['){
                multiStack.addLast(multi);
                resStack.addLast(res.toString());
                multi = 0;
                res = new StringBuilder();
            } else if (c == ']'){
                StringBuilder tsb = new StringBuilder();
                int round = multiStack.removeLast();
                for (int r = 0; r < round; r++){
                    tsb.append(res);
                }
                res = new StringBuilder(resStack.removeLast() + tsb);
            } else if (((c - '0') >= 0) && (('9' - c) >= 0)){
                multi = multi * 10 + (c - '0');
            } else {
                res.append(c);
            }
        }
        return res.toString();
    }
}
```

### 分析

维持两个栈，一个倍数栈，一个字符串栈，'['时进栈，']'时出栈，每次进栈时，倍数和字符串都要重置，每次出栈，字符串要根据出栈的倍数和字符串进行拓展还原。

参考：
[字符串解码](https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked)


## 739. 每日温度（复习）

### 题目

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

### 题解

```
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Deque<int[]> stack = new LinkedList<>();
        int[] res = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++){
            if (stack.isEmpty()){
                stack.addLast(new int[]{i, temperatures[i]});
            } else {
                while (!stack.isEmpty() && stack.peekLast()[1] < temperatures[i]){
                    res[stack.peekLast()[0]] = i - stack.peekLast()[0];
                    stack.removeLast();
                }
                stack.addLast(new int[]{i, temperatures[i]});
            }
        }
        return res;
    }
}
```

### 分析

单调栈法，栈元素为索引和值的数组，如果栈顶元素的值小于当前元素，说明温度第一次上升了，通过索引差值可以得到结果，然后栈顶出栈，直到栈顶元素大于当前元素或者栈为空时再将当前元素入栈。

参考：
[每日温度](https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked)


## 84. 柱状图中最大的矩形

### 题目

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

### 题解

```
class Solution {
    public int largestRectangleArea(int[] heights) {
        int res = 0;
        int[] nh = new int[heights.length + 2];
        for (int i = 0; i < heights.length; i++){
            nh[i + 1] = heights[i];
        }
        Deque<int[]> stack = new LinkedList<>();
        stack.addLast(new int[]{0, 0});
        for (int i = 1; i < nh.length; i++){
            while(stack.peekLast()[1] > nh[i]){
                int[] e = stack.removeLast();
                int w = i - stack.peekLast()[0] - 1;
                int h = e[1];
                res = Math.max(res, w * h);
                
            }
            stack.addLast(new int[]{i, nh[i]});
        }
        return res;
    }
}
```

### 分析

哨兵加单调栈，这个题解的第一个精髓是哨兵，可以免去边界值的考虑，极大降低解题的复杂程度，第二重点是矩形的宽度考虑，为什么是i - stack.peekLast()[0] - 1而不是i-出栈的索引，因为在出栈的索引前可能还有几个早就出栈的竖条，这些竖条的高度肯定不比当前出栈的高度低，所以当前出栈的高度对应的左边界应该在栈顶，所以为i - stack.peekLast()[0] - 1。

参考：
[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&envId=top-100-liked)


## 45. 跳跃游戏 II（复习）

### 题目

给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

0 <= j <= nums[i] 
i + j < n
返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

### 题解

```
class Solution {
    public int jump(int[] nums) {
        int start = 0;
        int end = 1;
        int res = 0;
        while (end < nums.length){
            int maxP = start;
            for (int i = start; i < end; i++){
                maxP = Math.max(maxP, i + nums[i]);
            }
            res++;
            start = end;
            end = maxP + 1;
        }
        return res;
    }
}
```

### 分析

类似于二叉树层次遍历一样，一层一层遍历即可，直到可以达到终点。

参考：
[跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-100-liked)


## 763. 划分字母区间（复习）

### 题目

给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。

### 题解

```
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        for (int i = 0; i < s.length(); i++){
            last[s.charAt(i) - 'a'] = i;
        }
        int start = 0;
        int end = 0;
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < s.length(); i++){
            end = Math.max(last[s.charAt(i) - 'a'], end);
            if (i == end){
                res.add(end - start + 1);
                start = end + 1;
            }
        }
        return res;
    }
}
```

### 分析

也是类似一层一层的找，思路类似上题

参考：
[划分字母区间](https://leetcode.cn/problems/partition-labels/?envType=study-plan-v2&envId=top-100-liked)


## 118. 杨辉三角（复习）

### 题目

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

### 题解

```
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
        res.add(Arrays.asList(new Integer[]{1}));
        if (numRows == 1){
            return res;
        }
        res.add(Arrays.asList(new Integer[]{1, 1}));
        Integer[] pre = new Integer[]{1, 1};
        while (pre.length < numRows){
            Integer[] cur = new Integer[pre.length + 1];
            Arrays.fill(cur, 1);
            for (int i = 1; i < cur.length - 1; i++){
                cur[i] = pre[i - 1] + pre[i];
            }
            res.add(Arrays.asList(cur));
            pre = cur;
        }
        return res;
    }
}
```

### 分析

思路简单，只是边界稍微需要注意点

参考：
[杨辉三角](https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked)


## 198. 打家劫舍

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

### 题解

```
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 1){
            return nums[0];
        }
        if (nums.length == 2){
            return Math.max(nums[0], nums[1]);
        }
        if (nums.length == 3){
            return Math.max(nums[1], nums[0] + nums[2]);
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        dp[2] = Math.max(nums[1], nums[0] + nums[2]);
        for (int i = 3; i < nums.length; i++){
            dp[i] = Math.max(Math.max(nums[i] + dp[i - 3], nums[i] + dp[i - 2]),dp[i - 1]);
        }
        return dp[dp.length - 1];
    }
}
```

### 分析

转移方程中极易漏掉的一点，dp[i] = Math.max(dp[i - 1], Math.max(dp[i - 2] + nums[i],dp[i - 3] + nums[i]))，有可能隔两个再加。

参考：
[打家劫舍](https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked)


## 279. 完全平方数（复习）

### 题目

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

### 题解

```
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++){
            int t = Integer.MAX_VALUE;
            for (int e = 1; e * e <= i; e++){
                t = Math.min(t, dp[i - e * e] + 1);
            }
            dp[i] = t;
        }
        return dp[n];
    }
}
```

### 分析

在内层遍历的时候直接从完全平方数数着手，效率高很多

参考：
[完全平方数](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)


## 322. 零钱兑换（复习）

### 题目

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

### 题解

```
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        for (int i = 1; i <= amount; i++){
            int t = Integer.MAX_VALUE;
            for (int coin : coins){
                if (i - coin < 0 || dp[i - coin] == -1){
                    continue;
                }
                t = Math.min(t, dp[i - coin] + 1);
            }
            dp[i] = t == Integer.MAX_VALUE ? -1 : t;
        }
        return dp[amount];
    }
}
```

### 分析

和上一题差不多了，麻了。

参考：
[零钱兑换](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked)


## 139. 单词拆分（复习）

### 题目

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

### 题解

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i < dp.length; i++){
            boolean f = false;
            for (String word : wordDict){
                if (i - word.length() >= 0 && dp[i - word.length()] == true && word.equals(s.substring(i - word.length(),i))){
                    f = true;
                    break;
                }
            }
            dp[i] = f;
        }
        return dp[dp.length - 1];
    }
}
```

### 分析

好像和上题还是差不多

参考：
[单词拆分](https://leetcode.cn/problems/word-break/solutions/?envType=study-plan-v2&envId=top-100-liked)


## 300. 最长递增子序列（复习）

### 题目

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

### 题解

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int res = 1;
        dp[0] = 1;
        for (int i = 0; i < nums.length; i++){
            int t = 1;
            for (int j = 0; j < i; j++){
                if (nums[i] > nums[j]){
                    t = Math.max(t, dp[j] + 1);
                }
            }
            dp[i] = t;
            res = Math.max(res, dp[i]);
        }
        return res;

    }
}
```

### 分析

动态规划，有的状态基于前面一两个就行，还有的是要遍历前面所有状态的，背包问题就是这样的，这个题目也是这样的。

参考：
[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)



## 152. 乘积最大子数组（复习）

### 题目

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

### 题解

```
class Solution {
    public int maxProduct(int[] nums) {
        int[] maxDp = new int[nums.length];
        int[] minDp = new int[nums.length];
        maxDp[0] = nums[0];
        minDp[0] = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++){
            if (nums[i] > 0){
                maxDp[i] = Math.max(nums[i], nums[i] * maxDp[i - 1]);
                minDp[i] = Math.min(nums[i], nums[i] * minDp[i - 1]);
            } else {
                maxDp[i] = Math.max(nums[i], nums[i] * minDp[i - 1]);
                minDp[i] = Math.min(nums[i], nums[i] * maxDp[i - 1]);
            }
            res = Math.max(res, maxDp[i]);
        }
        return res;
    }
}
```

### 分析

这个略难，需要维护两个状态，感觉算多维动态规划了。需要根据nums[i]是否为正进行分别考虑，另外还要考虑是否直接用nums[i]表示当前的最大或者最小乘积。

参考：
[乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked)


## 32. 最长有效括号（复习）

### 题目

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

### 题解

```
class Solution {
    public int longestValidParentheses(String s) {
        if (s.length() <= 1){
            return 0;
        }
        int[] dp = new int[s.length()];
        int res = 0;
        for (int i = 1; i < s.length(); i++){
            char ci = s.charAt(i);
            if (ci == ')'){
                if (s.charAt(i - 1) == '('){
                    if (i - 2 < 0){
                        dp[i] = 2;
                    } else {
                        dp[i] = 2 + dp[i - 2];
                    }
                } else {
                    if (dp[i - 1] != 0){
                        if (i - 1 - dp[i - 1] >= 0 && s.charAt(i - 1 - dp[i - 1]) == '('){
                            if (i - 1 - dp[i - 1] == 0){
                                dp[i] = dp[i - 1] + 2;
                            } else {
                                dp[i] = dp[i - 1] + 2 + dp[i - 2 - dp[i - 1]];
                            }
                        }
                    }
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

### 分析

动态规划。状态int[] dp，dp[i]表示以第i个字符为结尾的最长有效括号数。
如果s.charAt(i) == '('，dp[i] = 0，因为以'('结尾的字符串不是有效括号字符串。
如果s.charAt(i) == ')'，则有两种有效字符串的情况，第一种为i - 1为'('，则dp[i] = (i - 2) >= 0 ? dp[i - 2] + 2 : 2，另一种(i - dp[i - 1] - 1) >= 0 && s.charAt(i - dp[i - 1] - 1) == '('，则dp[i] = (i - dp[i - 1] - 2) >= 0 ? dp[i - 1] + 2 + dp[i - dp[i - 1] - 2] : dp[i - 1] + 2。
最终结果在每次便利中取较大值即可。

参考：
[最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)

## 5. 最长回文子串（复习）

### 题目

给你一个字符串 s，找到 s 中最长的回文子串。
如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

### 题解

```
class Solution {
    public String longestPalindrome(String s) {
        if (s.length() < 2){
            return s;
        }
        int b = 0;
        int len = 1;
        boolean[][] dp = new boolean[s.length()][s.length()];
        for (int i = 0; i < s.length(); i++){
            dp[i][i] = true;
        }
        for (int j = 1; j < s.length(); j++){
            for(int i = 0; i < j; i++){
                if(s.charAt(i) != s.charAt(j)){
                    dp[i][j] = false;
                } else {
                    if(j - i < 3){
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] && j - i + 1 > len){
                    len = j - i + 1;
                    b = i;
                }
            }
        }
        return s.substring(b, b + len);

    }
}
```

### 分析

基于二维dp进行遍历。dp[i][j]表示字符串从i到j是否是回文字符串。注意特殊情况为子字符串长度小于等于3的时候。这个题目技巧性较强，好好复习记忆。

参考：
[最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-100-liked)

## 1143. 最长公共子序列（复习）

### 题目

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

### 题解

```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int M = text1.length();
        int N = text2.length();
        int[][] dp = new int[M + 1][N + 1];
        for (int i = 1; i <= M; i++){
            for (int j = 1; j <= N; j++){
                if (text1.charAt(i - 1) == text2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[M][N];
    }
}
```

### 分析

int[][] dp，dp[i][j]表示从text1.substring(0, i)和text2.substring(0, j)的最大公共子序列。

参考：
[最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&envId=top-100-liked)

## 31. 下一个排列

### 题目

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

### 题解

```
class Solution {
    public void nextPermutation(int[] nums) {
        int f = nums.length - 1;
        while (f > 0 && nums[f] <= nums[f - 1]){
            f--;
        }
        if (f == 0){
            rev(nums, 0, nums.length - 1);
            return;
        }
        int k = nums.length - 1;
        while (k >= f){
            if (nums[k] > nums[f - 1]){
                break;
            }
            k--;
        }
        int num = nums[k];
        nums[k] = nums[f - 1];
        nums[f - 1] = num;
        rev(nums, f, nums.length - 1);

    }
    public void rev(int[] nums, int start, int end){
        while (start <= end){
            int num = nums[end];
            nums[end] = nums[start];
            nums[start] = num;
            start++;
            end--;
        }
    }
}
```

### 分析

背吧

参考：
[下一个排列](https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked)


## 287. 寻找重复数（复习）

### 题目

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

### 题解

```
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = nums[0];
        int fast = nums[nums[0]];
        while (slow != fast){
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        fast = 0;
        while (slow != fast){
            slow = nums[slow];
            fast = nums[fast];
        }
        return fast;
    }
}
```

### 分析

考虑成有环链表，快慢指针，背吧。
但本题的场景和限制是极其特殊的，实际工作中和绝大多数算法问题都不会用「时间换空间」；
关于如何使用「二分查找」做对「力扣」上所有的问题，可以看第 35 题的 题解；
这题二分查找和快慢指针都不是常规思路，面试的时候最好提一下：因为有各种限制，才用二分这种耗时的做法，用快慢指针是因为做过类似的问题。

参考：
[寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked)

## 215. 数组中的第K个最大元素（背）

### 题目

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

### 题解

```
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        for (int num : nums){
            heap.add(num);
            if (heap.size() > k){
                heap.poll();
            }
        }
        return heap.peek();
    }
}
```

### 分析

小顶堆，java优先队列，循环加，超过了就删，最后最顶上的就是第K大的数字

参考：
[数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked)
[详解数据结构——堆](https://zhuanlan.zhihu.com/p/85518062)

## 295. 数据流的中位数(复习)

### 题目

中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

例如 arr = [2,3,4] 的中位数是 3 。
例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。
实现 MedianFinder 类:

MedianFinder() 初始化 MedianFinder 对象。

void addNum(int num) 将数据流中的整数 num 添加到数据结构中。

double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。

### 题解

```
class MedianFinder {
    PriorityQueue<Integer> d1 = new PriorityQueue<>((x, y) -> y - x);
    PriorityQueue<Integer> d2 = new PriorityQueue<>();
    public MedianFinder() {
    }
    public void addNum(int num) {
        if (d2.size() == 0){
            d2.add(num);
        } else if (d1.size() == d2.size()){
            d1.add(num);
            d2.add(d1.poll());
        } else {
            d2.add(num);
            d1.add(d2.poll());
        }
    }
    public double findMedian() {
        if (d1.size() != d2.size()){
            return (double)d2.peek();
        } else {
            return (d1.peek() + d2.peek()) / 2.0d;
        }
    }
}
```

### 分析

l = new PriorityQueue<>((a, b) -> b - a);降序，大顶堆
r = new PriorityQueue<>((a, b) -> a - b);升序，小顶堆
经典题目，一个小顶堆放较大的数据，一个大顶堆放较小的数据。
使小顶堆的元素数量等于大顶堆的元素数量或多一个，如果小顶堆多一个，则堆顶是中位数，否则两个堆顶的平均数是中位数。
放元素的时候需要考虑两个堆元素是否相同的场景，元素相同或者小顶堆为空时，这时和大顶堆对比，优先放小顶堆，如果元素属于大顶堆，则把大顶堆的堆顶挪到小顶堆，再把当前元素放到大顶堆。

参考：
[数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked)

# 参考

[LeetCode 热题 100](https://leetcode.cn/studyplan/top-100-liked/)
LeetCode 热题 100相关题解


